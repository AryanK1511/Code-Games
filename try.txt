# ===== VARIABLES =====

# ===== LAST TICK VARIABLES SAVER =====
function save_vars()
  last_enemy_visible = enemy_visible
  last_enemy_angle = enemy_angle
  last_enemy_distance = enemy_distance
  last_energy = energy
  last_speed = speed
  last_direction = direction
end

# ===== HELPER FUNCTIONS =====

# --- Zig Zag Motion ----
function zig_zag_motion()
  # Set a random turn amount if it is 0
  if turn_amount == 0
    turn_amount = rand(5, 15)
  end

  # Switch the direction of turning if the turning variable is exhausted
  if turning <= 0
    turning = rand(20, 50)
    turn_amount *= -1
  end

  # Turn in some direction and reduce the turning variable
  if turning > 0
    right(turn_amount)
    turning -= 1
  end
end

# --- Used to control the speed of the ship ---
function control_speed()
  # Define dynamic speed thresholds based on tactical needs
  max_combat_speed = 3  # Optimal speed for combat maneuvering and accuracy
  cruising_speed = 4    # Speed for general movement around the arena
  max_speed = 5         # Maximum speed for fast repositioning or evasion

  # Adjust speed based on current tactical situation
  if enemy_visible
    # When the enemy is visible, decide speed based on their distance
    if enemy_distance < 100
      # If very close to the enemy, slow down for precise maneuvering and combat
      target_speed = max_combat_speed
    else if enemy_distance > 300
      # If the enemy is far, increase speed to close the gap or to evade effectively
      target_speed = max_speed
    else
      # Maintain a moderate speed for balanced maneuverability and reaction time
      target_speed = cruising_speed
    end
  else
    # If the enemy is not visible, use maximum speed to search and intercept
    target_speed = max_speed
  end
  
  current_speed_diff = target_speed - speed

  # Determine the rate of speed change based on the urgency of the situation
  if abs(current_speed_diff) > 1
    speed_change_rate = 5  # More aggressive speed change
  else
    speed_change_rate = 3  # Gradual speed change
  end

  # Adjust speed gradually towards the target speed
  if current_speed_diff > 0
    faster(speed_change_rate)
  else if current_speed_diff < 0
    slower(speed_change_rate)
  end
end

# --- Manage Ticks ---
function manage_ticks()
  if ticks == 0
    # Store our energy when the enemy shot last to last time
    energy_two_seconds_ago = energy
  end
  # Reset ticks every 2 seconds
  ticks = (ticks + 1) % 100
end

# --- Emergency evade ---
function emergency_evade_if_required()
  # Evade if we got hit twice in a row
  if energy_two_seconds_ago - energy == 2
    # Determine the optimal evasion direction based on the enemy's location and angle
    # Check the current enemy angle to decide the best turn direction
    if enemy_angle > 0
      # If enemy is to the right, turn left sharply to evade
      left(180 - enemy_angle)
    else
      # If enemy is to the left, turn right sharply to evade
      right(180 + enemy_angle)
    end

    # Use rift to quickly move in the evasion direction
    rift
  end
end

# --- Used to track and shoot the enemy ---
function track_and_shoot()
  # Calculate the time it takes for a shot to reach the enemy
  shot_time = enemy_distance / 500  

  # Predict future position of the enemy
  future_enemy_angle = enemy_angle + (enemy_speed * shot_time * sin(enemy_angle * 3.14 / 180))
  future_enemy_distance = enemy_distance + (enemy_speed * shot_time * cos(enemy_angle * 3.14 / 180))

  # Adjust the ship's direction to aim at the future position of the enemy
  aim_at_future_position(future_enemy_angle, future_enemy_distance)

  # Fire when the alignment is close to the predicted future position
  if abs(future_enemy_angle) < 5 and future_enemy_distance < 150
    fire
  end
end

function aim_at_future_position(future_enemy_angle, future_enemy_distance)
  # Calculate the absolute angle to the future position of the enemy
  future_absolute_angle = (last_direction + future_enemy_angle) % 360

  # Calculate the angle difference between the ship's current direction and the future absolute angle
  angle_difference = future_absolute_angle - last_direction

  # Normalize the angle difference to the range [-180, 180]
  if angle_difference > 180
    angle_difference -= 360
  else if angle_difference < -180
    angle_difference += 360
  end

  # Turn towards the future position of the enemy
  if angle_difference > 0
    right(angle_difference)
  else
    left(-angle_difference)
  end
end

function evade()
  projectile_travel_speed = 15 # Units per tick
  
  # Calculate the time it would take for the projectile to reach you
  projectile_travel_time = enemy_distance / projectile_travel_speed
  
  # Calculate deltas
  delta_angle = enemy_angle - last_enemy_angle
  delta_distance = enemy_distance - last_enemy_distance
  
  # Predict the enemy's future position based on their deltas
  predicted_future_enemy_angle = last_enemy_angle + (delta_angle * projectile_travel_time)
  predicted_future_enemy_distance = last_enemy_distance + (delta_distance * projectile_travel_time)
  
  # Determine an evasion direction that is perpendicular to the enemy's predicted line of fire
  # We choose to evade to the side opposite to the predicted future angle
  evasion_angle = predicted_future_enemy_angle > 0 ? -90 : 90
  
  # Use the evasion angle to maneuver the ship
  maneuver_to_evasion_point(evasion_angle, predicted_future_enemy_distance)
  

# --- Function to evade the opponent ---
function evade_and_seek()
  enemy_shot_time = 50 

  # Calculate the future position of the enemy in Cartesian coordinates
  future_x_position = enemy_distance * sin(enemy_angle * pi / 180) + (enemy_speed * enemy_shot_time * sin(enemy_angle * pi / 180))
  future_y_position = enemy_distance * cos(enemy_angle * pi / 180) + (enemy_speed * enemy_shot_time * cos(enemy_angle * pi / 180))

  # Convert the future position back to polar coordinates
  future_enemy_distance = sqrt(future_x_position*future_x_position + future_y_position*future_y_position)
  future_enemy_angle = atan2(future_y_position, future_x_position) * 180 / pi

  # Determine an evasion direction that is perpendicular to the enemy's predicted line of fire
  evasion_angle = future_enemy_angle + 90
  if evasion_angle > 360
    evasion_angle -= 360
  else if evasion_angle < 0
    evasion_angle += 360
  end

  # Calculate a safe distance to maintain from the predicted enemy position
  safe_distance = max(150, future_enemy_distance)  # Ensure a minimum safe distance

  # Use the evasion angle and safe distance to maneuver the ship
  maneuver_to_evasion_point(evasion_angle, safe_distance)
end

# --- Function to change direction to evade ---
function maneuver_to_evasion_point(evasion_angle, safe_distance)
  # Turn the ship towards the evasion angle
  future_absolute_angle = (last_direction + evasion_angle) % 360
  angle_difference = future_absolute_angle - last_direction

  # Normalize the angle difference
  if angle_difference > 180
    angle_difference -= 360
  else if angle_difference < -180
    angle_difference += 360
  end

  # Execute the turn
  if angle_difference > 0
    right(angle_difference)
  else
    left(-angle_difference)
  end

  # Adjust the speed to maintain the safe distance
  if enemy_distance < safe_distance
    faster
  else
    slower
  end
end

enemy_angular_displacement = enemy_angle - last_enemy_angle


# =========================
# ===== MAIN FUNCTION =====
# =========================
function play_game()
  # Manage ticks
  manage_ticks
  
  # Save variables from the previous tick
	save_vars  
  
  # Evade if in a bad situation
  emergency_evade_if_required
  
  # Control the speed and move zig zag everytime
  control_speed
  #zig_zag_motion
  
  # Shift strategy when spotting the enemy
#  if enemy_visible
#	  track_and_shoot
 # else
  evade_and_seek
   #end
end

# Calling the play_game() function and executing the logic
play_game


function follow_and_fire()
  # Constants
  shot_speed = 15 # speed of the shot

  # Calculate time to hit based on current distance and shot speed
  time_to_hit = enemy_distance / shot_speed

  # Predict future position of the enemy
  predicted_enemy_x = cos(enemy_angle) * enemy_distance + cos(enemy_direction) * enemy_speed * time_to_hit
  predicted_enemy_y = sin(enemy_angle) * enemy_distance + sin(enemy_direction) * enemy_speed * time_to_hit

  # Calculate angle to the predicted position
  lead_angle = atan2(predicted_enemy_y, predicted_enemy_x)

  # Turn towards the predicted future position of the enemy
  if lead_angle > 0
    right(abs(lead_angle))
  else
    left(abs(lead_angle))
  end

  # Adjust speed to maintain optimal distance
  faster(enemy_distance - 130)

  # Fire if the enemy is within a reasonable distance
  if enemy_visible and enemy_distance <= 250
    fire
  end
end